



#### happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的   

>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个
操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前


>1，程序顺序规则
>2，监视器锁规则
>3，volatile变量规则
>4，传递性：A happens-before B，B happens-before C =》 A happens-before C
>5，start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
>6，join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回


#### as-if-serial:不管怎么排序，结果不能被改变
>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变

#### 排序
>1，编译器优化重排序-》指令级并行重排序-》内存系统重排序-》最终执行指令序列

#### CAS：Compare and Swap
>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止

### 关键字

#### volatile
>1，各个线程会将共享变量从主内存中拷贝到工作内存（缓存），然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象               
>2，在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出 **Lock前缀的指令，其影响：1）将当前处理器缓存行的数据写回系统内存，2）这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效**   
>3,从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义  



>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。

##原子性
>1，使用循环CAS保证原子性
>2，用锁机制

>处理器在处理复杂内存操作不能保证原子性，例如跨总线宽度，跨多个缓存行，跨页表等，使用总线锁定和缓存锁定来保证负责内存操作的原子性

>总线锁定（LOCK#指令）使其他处理器被阻塞，开销大
>缓存锁定：修改内部内存地址，并使用缓存一致性机制
>有两种情况下处理器不会使用缓存锁定：
>1）第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。
>2）第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定


## 并发编程
>1，两个关键问题：线程通信和同步
>2，线程通信机制：共享内存和消息传递

## JMM和顺序一致性模型
>1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的
操作会按程序的顺序执
>2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程
能看到一致的操作执行顺
>3）JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保
证对所有的内存读/写操作都具有原子性。与处理器 **总线的工作机制** 密切相关

### 总线机制
>1，总线事务
>2，总线仲裁